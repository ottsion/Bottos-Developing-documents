# C++

# 1. Contract compilation (C/C++ version)

The C/C++ contract compilation tool chain is in the following Library:

<https://github.com/bottos-project/contract-tool-cpp.git>

This tool is used to compile C/C++ contracts, generate wasm/wast files, and scan to generate ABI files. Here are two examples from the library:

## 1. Example testHelloWorld      

A contract code is placed in a folder, and the folders are placed in the "contract-tool-cpp" folder, such as testHelloWorld.

To compile a contract, enter the contract directory first, such as the testHelloWorld directory, where the contract is compiled using the following commands, so that testHelloWorld. wast and testHelloWorld. wasm are generated in the same directory:

```
python ../gentool.py wasm testHelloWorld.cpp
```

Since ABI is not involved in this example, let's describe what ABI generates in the following example.

## 2. Example testRegUser

The compiling contract, like the previous example, enters the testRegUser directory to compile the contract with the following commands:

```
python ../gentool.py wasm testRegUser.cpp
```

Let's focus on the generation of the contract ABI file. First, let me briefly introduce the composition of the ABI file:

- structs ：The definition of the scanning structure is described for later use.
- actions：The contract provides a method description in which `action_name` is the method name and `type` is the parameter required to invoke the contract.
- tables ：Contract persistent data access interface description, where `table_name` is the table name, `index_type` is the type of index, `key_names` and `key_types` are the name and type of the key value, and `type` is the structure definition of the content.

The ABI file is generated by scanning the HPP file and annotated in the HPP file to tell the scanner the specific definition:

- "//@abi action reguser"：

​        A method `reguser` is defined, and the corresponding entry parameter is defined as `UserInfo`.

- "//@abi table userinfo:[index_type:string， "key_names:userName， key_types:string] "：

​       A table is defined, and the structure of table content is defined as `UserBaseInfo`.

Under the testRegUser folder, you can scan the corresponding ABI files of the HPP file through the following commands:

```
python ../gentool testRegUser.hpp
```

# 2. Contract writing (C/C++ version)

## 2.1.  a simplest contracts.      

The entry function to the contract is the start function. We create a simple contract by printing "hello world in start" when the contract is called:

```
#include "contractcomm.hpp"

int start(char* method) 
{
    myprints("hello world in start");

    return 0;
}

```

Among them, "contractcomm.hpp" is a commonly used basic interface declaration file.

Calling this contract will print "Hello world in start" in the log of the node:

```
2018-08-06 16:05:20 [INF] vm/wasm/exec/env_func.go:390 prints(): VM: func prints: hello world in start

```

## 2.2. Get the method of calling the contract

When invoking a contract, we need to specify a specific method for invoking the contract, namely the following "method" parameter "test_method":

```
{"version":1, "cursor_num":28,"cursor_label":3745260307,"lifetime":15270819998,"sender":"example", "contract":"example", "method":"test_method", "param":"", "sig_alg":1, "signature":""}

```

This method is passed into the contract by the start function input parameter, which is the method parameter below. We add a statement to the contract that prints the parameter:

```
#include "contractcomm.hpp"

int start(char* method) 
{
    myprints("hello world in start");
    myprints(method);

    return 0;
}

```

We construct a transaction that sets the method to a specific string, the following "test_method": (the signature value is omitted here, the same as below)

```
{"version":1, "cursor_num":28,"cursor_label":3745260307,"lifetime":15270819998,"sender":"example", "contract":"example", "method":"test_method", "param":"", "sig_alg":1, "signature":""}

```

 Calling this contract, you will have the following log output: print the "method" parameter of the settings, that is, "test_method":      

```
2018-08-07 14:40:22 [INF] vm/wasm/exec/env_func.go:412 prints(): VM: func prints: hello word in start

2018-08-07 14:40:22 [INF] vm/wasm/exec/env_func.go:412 prints(): VM: func prints: test_method

```

We can provide different contract implementations in the contract according to method, that is, methods, by comparing method parameters and then moving to different method branches, such as the "add" and "del" methods provided in the following contract:

```
#include "contractcomm.hpp"
#include "string.hpp"

int start(char* method) 
{
    myprints("hello word in start");
    myprints(method );

    if (0 == strcmp("add", method))
    {
        myprints("it is method add");
    }
    else if (0 == strcmp("del", method))
    {
        myprints("it is method del");
    }

    return 0;
}

```

## 2.3. Get call contract parameters

When invoking a contract, you need to specify not only the method to invoke the contract, but also the corresponding parameters, namely the following "param" parameters:

```
{"version":1, "cursor_num":28,"cursor_label":3745260307,"lifetime":15270819998,"sender":"example", "contract":"example", "method":"test_method", "param":"", "sig_alg":1, "signature":""}

```

In the contract, you can get the parameter through the "getParam" interface, for example:

```
#include "contractcomm.hpp"
#define ERROR_PARAM (-1)

int start(char* method) 
{
    char param[PARAM_MAX_LEN];
    uint32_t paramLen = 0;    

    paramLen = getParam(param, PARAM_MAX_LEN);

    if (0 == paramLen) 
    {
        myprints("paramLen is 0, error");
        return ERROR_PARAM;
    }

    myprints("paramLen is:");
    printi(paramLen);    
    myprints("param detail:");
    for(int i = 0;i<paramLen;i++)
    {
        printi(param[i]);
    }

    return 0;
}

```

 We construct a transaction where the parameters are serialized via MessagePack, for example, we need to pass a serialized parameter [97, 98, 99], convert the serialized value into a hexadecimal string:'616263', and then fill in the param:      

```
{"version":1, "cursor_num":28,"cursor_label":3745260307,"lifetime":15270819998,"sender":"example", "contract":"example", "method":"test_method", "param":"616263", "sig_alg":1, "signature":""}

```

Calling this contract, you will have the following log output, which is the serialized value of [97, 98, 99] in the contract:

```
2018-08-08 17:25:26 [INF] vm/wasm/exec/env_func.go:431 prints(): VM: func prints: paramLen is:

2018-08-08 17:25:26 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 3

2018-08-08 17:25:26 [INF] vm/wasm/exec/env_func.go:431 prints(): VM: func prints: param detail:

2018-08-08 17:25:26 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 97

2018-08-08 17:25:26 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 98

2018-08-08 17:25:26 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 99

```

## 2.4. Storage and reading of contract data

In order to facilitate unified access to data, we require MessagePack to serialize the data to be saved by the contract, and deserialize the read data to get the original data.


We define a structure for testing:

```
struct TestStruct {
    uint32_t valueA;
    uint32_t valueB;
};

```

We pass in a parameter of type TestStruct through param, where the values of the fields are filled in 1 and 2, respectively. First we serialize it and get [220, 0, 2, 206, 0, 0, 0, 1, 206, 0, 0, 0, 2], which is converted into a hexadecimal string: "dc0002ce00001ce00002", and we fill the param in the transaction with this value:

```
{"version":1, "cursor_num":28,"cursor_label":3745260307,"lifetime":15270819998,"sender":"example", "contract":"example", "method":"test_method", "param":"dc0002ce00000001ce00000002", "sig_alg":1, "signature":""}

```

We reverse the parameters introduced in the contract:

```
#include "contractcomm.hpp"
#define ERROR_PARAM (-1)
#define ERROR_UNPACK (-2)

struct TestStruct {
    uint32_t valueA;
    uint32_t valueB;
};


static bool unpack_struct(MsgPackCtx *ctx, TestStruct *info)
{    
    uint32_t size = 0;

    if (!unpack_array(ctx, &size)) return false; 
    if (2 != size) return false;

    if (!unpack_u32(ctx, &info->valueA)) return false; 
    if (!unpack_u32(ctx, &info->valueB)) return false; 

    return true;
}

static bool pack_struct(MsgPackCtx *ctx, TestStruct *info)
{    
    if (!pack_array16(ctx, 2)) return false;

    if (!pack_u32(ctx, info->valueA)) return false; 
    if (!pack_u32(ctx, info->valueB)) return false; 

    return true;
}

int start(char* method) 
{
    char param[PARAM_MAX_LEN];
    uint32_t paramLen = 0;    

    paramLen = getParam(param, PARAM_MAX_LEN);

    if (0 == paramLen) 
    {
        myprints("paramLen is 0, error");
        return ERROR_PARAM;
    }

    MsgPackCtx ctx;
    msgpack_init(&ctx, (char*)param, paramLen);

    TestStruct testStruct;
    bool suc = unpack_struct(&ctx, &testStruct);
    if (!suc)
    {
        myprints("unpack struct error");        
        return ERROR_UNPACK;
    }

    myprints("data from input param:");
    printi(testStruct.valueA);
    printi(testStruct.valueB);

    return 0;
}

```

Calling this contract, we can see that the structure in it correctly gets the parameters set at the time of the call, which are 1 and 2:

```
2018-08-08 18:20:00 [INF] vm/wasm/exec/env_func.go:431 prints(): VM: func prints: data from input param:

2018-08-08 18:20:00 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 1

2018-08-08 18:20:00 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 2

```

We rewrite the data and save it through the setBinValue interface, then read it out through getBinValue and deserialize it to get the real data:

```
#include "contractcomm.hpp"
#define ERROR_PARAM (-1)
#define ERROR_UNPACK (-2)
#define ERROR_SAVE_DB (-3)
#define ERROR_READ_DB (-4)
#define ERROR_CONTRACT_NAME (-5)

struct TestStruct {
    uint32_t valueA;
    uint32_t valueB;
};

static bool unpack_struct(MsgPackCtx *ctx, TestStruct *info)
{    
    uint32_t size = 0;

    if (!unpack_array(ctx, &size)) return false; 
    if (2 != size) return false;

    if (!unpack_u32(ctx, &info->valueA)) return false; 
    if (!unpack_u32(ctx, &info->valueB)) return false; 

    return true;
}

static bool pack_struct(MsgPackCtx *ctx, TestStruct *info)
{    
    if (!pack_array16(ctx, 2)) return false;

    if (!pack_u32(ctx, info->valueA)) return false; 
    if (!pack_u32(ctx, info->valueB)) return false; 

    return true;
}

int start(char* method) 
{
    char param[PARAM_MAX_LEN];
    uint32_t paramLen = 0;    

    paramLen = getParam(param, PARAM_MAX_LEN);
    if (0 == paramLen) 
    {
        myprints("paramLen is 0, error");
        return ERROR_PARAM;
    }

    /* Reverse param */
    MsgPackCtx ctx;
    msgpack_init(&ctx, (char*)param, paramLen);

    TestStruct testStruct;
    bool suc = unpack_struct(&ctx, &testStruct);
    if (!suc)
    {
        myprints("unpack struct error");

        return ERROR_UNPACK;
    }

    myprints("data from input param:");
    printi(testStruct.valueA);
    printi(testStruct.valueB);

    /* Rewrite fields to 3, 4 */
    testStruct.valueA = 3;
    testStruct.valueB = 4;

    /* Serialization operation */
    msgpack_init(&ctx, (char*)param, PARAM_MAX_LEN);
    suc = pack_struct(&ctx, &testStruct);
    if (!suc)
    {
        myprints("pack struct error");        
        return ERROR_UNPACK;
    }

    char tableName[] = "testTableName";
    char keyName[] = "testKeyName";

    /* Call the interface to save it. */
    uint32_t handleResult = setBinValue(tableName, strlen(tableName), keyName, strlen(keyName), ctx.buf, ctx.pos);
    if (0 == handleResult)
    {
        myprints("save to db error");        
        return ERROR_SAVE_DB;
    }

    char contractname[STR_ARRAY_LEN(USER_NAME_MAX_LEN)];   
    uint32_t contractNameLen = getCtxName(contractname, STR_ARRAY_LEN(USER_NAME_MAX_LEN));
    if (0 == contractNameLen)
    {
        myprints("contract name error");        
        return ERROR_CONTRACT_NAME;
    }

    /* Call the interface to get the value that is just saved. */
    handleResult = getBinValue(contractname, contractNameLen, tableName, strlen(tableName), keyName, strlen(keyName), param, PARAM_MAX_LEN);
    if (0 == handleResult)
    {
        myprints("read from db error");        
        return ERROR_READ_DB;
    }

    /* Anti serialization operation */
    msgpack_init(&ctx, (char*)param, handleResult);
    suc = unpack_struct(&ctx, &testStruct);
    if (!suc)
    {
        myprints("unpack struct error");        
        return ERROR_UNPACK;
    }

    myprints("data from db:");
    printi(testStruct.valueA);
    printi(testStruct.valueB);   

    return 0;
}

```

Call the contract again with the following transactions (input structure fields, fields 1 and 2, respectively):

```
{"version":1, "cursor_num":28,"cursor_label":3745260307,"lifetime":15270819998,"sender":"example", "contract":"example", "method":"test_method", "param":"dc0002ce00000001ce00000002", "sig_alg":1, "signature":""}

```

As can be seen from the log, the input fields are 1, 2, rewritten to 3, 4, and then saved, and finally read out of reverse order can still get the expected value, that is, the fields are 3, 4:

```
2018-08-08 18:38:34 [INF] vm/wasm/exec/env_func.go:431 prints(): VM: func prints: data from input param:

2018-08-08 18:38:34 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 1

2018-08-08 18:38:34 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 2

......

2018-08-08 18:38:34 [INF] vm/wasm/exec/env_func.go:431 prints(): VM: func prints: data from db:

2018-08-08 18:38:34 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 3

2018-08-08 18:38:34 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 4

```

## 2.5. Calling other contracts

The following is a computing contract, which implements the add method, that is, to compute the sum of two parameters:

```
#include "contractcomm.hpp"
#include "string.hpp"

#define ERROR_PARAM (-1)
#define ERROR_UNPACK (-2)
#define ERROR_INVALID_METHOD (-3)

struct TestStruct {
    uint32_t valueA;
    uint32_t valueB;
};

static bool unpack_struct(MsgPackCtx *ctx, TestStruct *info)
{    
    uint32_t size = 0;

    if (!unpack_array(ctx, &size)) return false; 
    if (2 != size) return false;

    if (!unpack_u32(ctx, &info->valueA)) return false; 
    if (!unpack_u32(ctx, &info->valueB)) return false; 

    return true;
}

static bool pack_struct(MsgPackCtx *ctx, TestStruct *info)
{ 
    if (!pack_array16(ctx, 2)) return false;

    if (!pack_u32(ctx, info->valueA)) return false; 
    if (!pack_u32(ctx, info->valueB)) return false; 

    return true;
}

int start(char* method) 
{
    if (0 == strcmp("add", method))
    {
        char param[PARAM_MAX_LEN];
        uint32_t paramLen = 0;    

        /* Get incoming parameters */
        paramLen = getParam(param, PARAM_MAX_LEN);

        if (0 == paramLen) 
        {
            myprints("paramLen is 0, error");
            return ERROR_PARAM;
        }

        /* De serialize the parameters and get the raw data. */
        MsgPackCtx ctx;
        msgpack_init(&ctx, (char*)param, paramLen);
        TestStruct testStruct;
        bool suc = unpack_struct(&ctx, &testStruct);
        if (!suc)
        {
            myprints("unpack struct error");

            return ERROR_UNPACK;
        }

        printi(testStruct.valueA);
        printi(testStruct.valueB);

        /* Print the sum of two parameters*/        
        myprints("add result is:");
        printi(testStruct.valueA + testStruct.valueB);
    }
    else
    {
        myprints("invalid method");

        return ERROR_INVALID_METHOD;
    }

    return 0;
}

```

Then we write a contract in which we call the computed contract above, which is passed to the two parameters of the computed contract above, and compute the sum of the two parameters in the computed contract: (Suppose the computed contract above is deployed on the compute contract account)

```
#include "contractcomm.hpp"
#define ERROR_UNPACK  (-1)
#define ERROR_CALLTRX (-2)

struct TestStruct {
    uint32_t valueA;
    uint32_t valueB;
};

static bool unpack_struct(MsgPackCtx *ctx, TestStruct *info)
{    
    uint32_t size = 0;

    if (!unpack_array(ctx, &size)) return false; 
    if (2 != size) return false;

    if (!unpack_u32(ctx, &info->valueA)) return false; 
    if (!unpack_u32(ctx, &info->valueB)) return false; 

    return true;
}

static bool pack_struct(MsgPackCtx *ctx, TestStruct *info)
{    
    if (!pack_array16(ctx, 2)) return false;

    if (!pack_u32(ctx, info->valueA)) return false; 
    if (!pack_u32(ctx, info->valueB)) return false; 

    return true;
}

int start(char* method) 
{
    char param[PARAM_MAX_LEN];
    TestStruct testStruct;

    testStruct.valueA = 3;
    testStruct.valueB = 4;    

    /* Serialization operation */
    MsgPackCtx ctx;
    msgpack_init(&ctx, (char*)param, PARAM_MAX_LEN);
    bool suc = pack_struct(&ctx, &testStruct);
    if (!suc)
    {
        myprints("pack struct error");        
        return ERROR_UNPACK;
    }  

    /* Define the name of the contract to be invoked and the method name. */
    char *callContractName = "calccontract";
    char *callMethod = "add";

    /* Invocation contract */
    uint32_t callResult = callTrx(callContractName , strlen(callContractName), callMethod, strlen(callMethod), ctx.buf , ctx.pos);
    if (0 != callResult)
    {
        myprints("call trx error");        
        return ERROR_CALLTRX;
    }

    myprints("call trx succed");       

    return 0;
}

```

If we call the above contract, we will have the following log:

```
2018-08-09 12:00:34 [INF] vm/wasm/exec/env_func.go:431 prints(): VM: func prints: call trx succed

2018-08-09 12:00:34 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:calccontract, method:add, func printi: 3

2018-08-09 12:00:34 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:calccontract, method:add, func printi: 4

2018-08-09 12:00:34 [INF] vm/wasm/exec/env_func.go:431 prints(): VM: func prints: add result is:

2018-08-09 12:00:34 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:calccontract, method:add, func printi: 7

```

## 2.6. Attached 1: interface function for calling together.

- void prints(char *str, uint32_t len);

  Function: print string 

  Parameter Description:


- void printi(uint64_t param);


- uint32_t setBinValue(char* object, uint32_t objLen, char* key, uint32_t keyLen, char *value, uint32_t valLen);

  Function: save data to chain.

  Parameter Description:

  Return value: length of saved data

- uint32_t getBinValue(char* contract, uint32_t contractLen, char* object, uint32_t objLen, char* key, uint32_t keyLen, char *valueBuf, uint32_t valueBufLen);

  Function: get data from the chain.

  Parameter Description:

  Return value: length of data obtained

- uint32_t removeBinValue(char* object, uint32_t objLen, char* key, uint32_t keyLen);

  Function: remove data from chain

  Parameter Description:

  Return value: length of deleted data

- uint32_t getParam(char *param, uint32_t bufLen);

  Function: get parameters when calling contract

  Parameter Description:

  Return value: the length of the parameter obtained.

- bool callTrx(char *contract , uint32_t contractLen, char *method , uint32_t methodLen,  char *buf , uint32_t bufLen );

  Function: invoke other contracts (asynchronous mode)

  Parameter Description:

  Return value: true: succeeded, false: failed.

- uint32_t getCtxName(char *str , uint32_t len);

  Function: get contract name

  Parameter Description:

  Return value: the length of the account name obtained.

- uint32_t  getSender(char *str , uint32_t len);

  Function: get the account name that calls the current contract.

  Parameter Description:

  Return value: the length of the account name obtained.

- bool isAccountExist(char *name， uint32_t nameLen);

  Function: check whether account exists.

  Parameter Description:

  Return value: true: exists, false: does not exist.

## 2.7. Serialization of 2:MessagePack

### 2.7.1  Summary      

In order to facilitate the transfer of parameters when calling the contract and read the persistent data of the contract, we choose MessagePack, a lightweight encoding and decoding method, for detailed specification reference.

<https://msgpack.org/>

<https://github.com/msgpack/msgpack/blob/master/spec.md>

In addition, we made some tailoring to the characteristics of contract data:


1. basic types: support uint8, uint16, uint32, Uint64, array16, bin16, str16 type;

2. Variable-length data: for example, str type, MessagePack original specification according to the length of the string to fill in the length of bytes, 1, 2, 4 byte length is different, after the transformation default use 2 bytes (str16), bin type and array type is also, that is, only support bin16, array16 type;

3. Structure: The structure is encapsulated in the form of array. When encoding, 16 arrays are written first, and then the fields are encoded in turn.


Example (C):

```
struct user_login {
    char user_name[USER_NAME_MAX_LEN];
    uint32_t random_num;
};

user_login login;
strcpy(login.user_name, "testuser");
login.random_num = 99;

pack_array16(&ctx, 2);
pack_str16(&ctx, login->user_name, strlen(login->user_name));
pack_u32(&ctx, login->random_num);

```

 Coding results:      

```
0xdc, 0x00, 0x02, 0xda, 0x00, 0x08, 0x74, 0x65, 0x73, 0x74, 0x75, 0x73, 0x65, 0x72, 0xce, 0x00, 0x00, 0x00, 0x63

```

### 2.7.2 Code specification      

**Types**

- **Integer** represents an integer
- Raw
  - **String** extending Raw type represents a UTF-8 string
  - **Binary** extending Raw type represents a byte array
- **Array** represents a sequence of objects

**Format**

| format name | first byte (in binary) | first byte (in hex) |
| ----------- | ---------------------- | ------------------- |
| bin16       | 11000101               | 0xc5                |
| uint8       | 11001100               | 0xcc                |
| uint16      | 11001101               | 0xcd                |
| uint32      | 11001110               | 0xce                |
| uint64      | 11001111               | 0xcf                |
| str16       | 11011010               | 0xda                |
| array16     | 11011100               | 0xdc                |

**Notation in diagrams**

```
one byte:
+--------+
|        |
+--------+

a variable number of bytes:
+========+
|        |
+========+

variable number of objects stored in MessagePack format:
+~~~~~~~~~~~~~~~~~+
|                 |
+~~~~~~~~~~~~~~~~~+

```

**int format family**

Int format family stores an integer in 2, 3, 5, or 9 bytes.

```
uint 32 stores a 32-bit big-endian unsigned integer
+--------+--------+--------+--------+--------+
|  0xce  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
+--------+--------+--------+--------+--------+

uint 64 stores a 64-bit big-endian unsigned integer
+--------+--------+--------+--------+--------+--------+--------+--------+--------+
|  0xcf  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
+--------+--------+--------+--------+--------+--------+--------+--------+--------+

```

**str format family**

Str format family stores a byte array in 3 bytes of extra bytes in addition to the size of the byte array.

```
str 16 stores a byte array whose length is upto (2^16)-1 bytes:
+--------+--------+--------+========+
|  0xda  |ZZZZZZZZ|ZZZZZZZZ|  data  |
+--------+--------+--------+========+

where
* ZZZZZZZZ_ZZZZZZZZ is a 16-bit big-endian unsigned integer which represents N
* N is the length of data

```

**bin format family**

Bin format family stores an byte array in 3 bytes of extra bytes in addition to the size of the byte array.

```
bin 16 stores a byte array whose length is upto (2^16)-1 bytes:
+--------+--------+--------+========+
|  0xc5  |YYYYYYYY|YYYYYYYY|  data  |
+--------+--------+--------+========+

where
* YYYYYYYY_YYYYYYYY is a 16-bit big-endian unsigned integer which represents N
* N is the length of data

```

**array format family**

Array format family stores a sequence of elements in 3 bytes of extra bytes in addition to the elements.

```
array 16 stores an array whose length is upto (2^16)-1 elements:
+--------+--------+--------+~~~~~~~~~~~~~~~~~+
|  0xdc  |YYYYYYYY|YYYYYYYY|    N objects    |
+--------+--------+--------+~~~~~~~~~~~~~~~~~+

where
* YYYYYYYY_YYYYYYYY is a 16-bit big-endian unsigned integer which represents N
    N is the size of a array

```

**Serialization: type to format conversion**

MessagePack serializers convert MessagePack types into formats as following:

| source types | output format                            |
| ------------ | ---------------------------------------- |
| Integer      | int format family (positive fixint uint 8/16/32/64) |
| String       | str format family (str16)                |
| Binary       | bin format family (bin16)                |
| Array        | array format family (array16)            |

**Deserialization: format to type conversion**

MessagePack deserializers convert MessagePack formats into types as following:

| source formats                  | output type |
| ------------------------------- | ----------- |
| positive fixint,uint 8/16/32/64 | Integer     |
| str16                           | String      |
| bin16                           | Binary      |
| array16                         | Array       |